
  
\section{Design Principles}
\label{sec:design}

%\subsection{Designing a Monitoring Solution}

There are several characteristics required for a good monitoring solution. We believe that the following are key towards such a design, and have followed them as our design principles.

\begin{enumerate}
  
  \item {Low Overhead}
  
  One of the most important, characteristics of a monitoring/instrumentation solution is a low overhead. While in development environment, this condition may be relaxed a little, in production environment it is extremely important. We have made iProbe to be extremely light-weight so as to ensure that it can be easily applied in production software with a minimal overhead. In general most solutions are kernel based and generally requires a context switch to kernel space each time you reach instrumentation code. iProve avoids this problem by having a completely user-space solution. Additionally, the entire instrumentation code is already a part of the code-segment of the target process and is only enabled or disabled.

  \item {Customizable}
  
  We have designed iProbe to provide an easy implementation to the user. Because of a hot-patching driven design, the instrumentation code is a part of the code-segment of the target process. Hence, iProbe gives a lot of flexibility to the user in how to use the instrumentation code. Apart from capturing execution tracing, and capturing fine-grained function level timing/resource based statistics, the instrumentation can also capture parameters, function return values etc, and much more.
  
  \item {Negligible Default Overhead} 
  
  Another desirable effect for a good monitoring solution is to have a minimal effect on the performance of the program when we are not instrumenting. Most production level monitoring is either sampled, or captured when a low throughput is observed. iProbe's effect when instrumentation is not turned on is almost negligible, and only occurs due to execution of no-op operations which are used as placeholders(explained in section.\ref{sec:implementation}).
  
  \item {Platform Independent}
  
  iProbe implementation is dependent on the availability of a hot-patching functionality in the target system.
  While we have currently tested our implementation on native linux environments (the linux distribution does not matter), hot patching is enabled in windows as well, and our implementation should work on windows as well.
  
  \item {Ease of deployment}
  
  The iProbe architecture is extremely easy to use, and requires no modification of the linux kernel/environment etc. We use a combination of commonly existing tools in linux to implement iProbe. While solutions like D-Trace also provide most of these functionalities, iProbe focuses on an easy deployment with a simpler and clearer functionality. As mentioned earlier, iProbe does not take a completely black-box approach unlike System Tap, DTrace, or Fay. Instead, we aim for minimal modification in the compile time which enables us to have a far-simpler and easier implementation.
  
 \item {Non-dependence on symbolic information}
 
One of the advantages of iProbe is it's non-dependence on symbolic information in the binaries. iProbe breaks the patching process

\end{enumerate}


