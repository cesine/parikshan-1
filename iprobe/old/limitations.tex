\section{Discussions  and Limitations}
\label{sec:disc_limitations}

There are two main assumptions/requirements for iProbe to be applied on any application; 1. Compiler Assistance, and 2. Hot-Patching capability. The basic idea as mentioned earlier is to use some compiler mechanism to introduce a placeholder, and then use hot-patching to patch the binary. 

For most common compilers such as java, gcc, g++ ,gcj etc. there are compiler modifications

One key mechanisms employed by iProbe is using compiler assistance as an enabler for doing hot-tracing. This idea is both helpful, and at the same time introduces a problematic limitation : the compilation process must be modified to introduce placeholders. Since our main goal for iProbe was a tool which can be packaged as a monitoring solution with the target application, we believe that the requirement for changing the compiler flags can be easily applied.

While technically speaking hot-tracing can be applied using a pure binary mechanism\cite{pannus,livepatch}, this generally has a higher overhead and is relatively complex, so as a design choice the current iProbe avoids this implementation to make significant gains in terms of the overhead. In our current implementation of iProbe, to ensure that compiler modification is easy and transparent to the user: we use an alias script which modifies any compilation to substitute the compiler with the requisite flags. 


1. Compiler driven, not completely automated: ease of implementation, compare it 
with D-Trace which requires extensive implementation and is hence platform 
dependent
2. Compiler optimization: Inlining, 
3. Currently tested on native, we believe can be used in java especially as the 
new ones with hot-patching, alternatively we have been trying to implement the 
same idea with transforming and reloading java class files.
4.We are backwards compatible