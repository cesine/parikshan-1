\subsection{Extended iProbe Mode}
\label{sec:advanced}

%Since the default mode of iProbe is compiler driven using instrumentation flags.
As iProbe ColdPatching requires compiler assistance, it is unable to operate on pre-packaged binary applications.
Additionally, compiler flags generally have limited instrumentation flexibility as they generally operate on a programming language abstraction(eg. function calls, loops etc.).
To provide further flexibility, iProbe provides a couple of extended options for ColdPatching of the application

\subsubsection{Static Binary Rewriting Mode} 
 In this mode we use a static binary rewriter to insert instrumentation in a pre-packaged binary. 
Once all functions are instrumented, we use a ColdPatching script to capture all call sites to the instrumentation functions and convert them to \texttt{NOP} instruction.
While this mode allows us to directly operate on binaries, a downside is that our current static binary instrumentation technique also uses mini-trampoline mechanisms. 
As explained in Section \ref{sec:trampoline} static binary rewriters use trampoline based mechanisms which induces minimum two jumps.
In the ColdPatch phase, we convert calls to the instrumentation function to \texttt{NOP}s, however the jmp operations to the trampoline function, and simulation of the overwritten instructions still remain.
The downside of this approach has a small overhead even when instrumentation is turned off.
However, in comparison to pure dynamic instrumentation approach it reduces the time spent in HotPatching.
This is especially important if the number of instrumentation targets is high, and the target binary is large, as it will increase the time taken in analyzing the binaries. 
Additionally, if compiler options cannot be changed for certain sections of the program (plugins/3rd party binaries), iProbe can still be applied using this extended feature.

Our current implementation uses the dyninst \cite{dyninst} and cobi \cite{cobi} to do static instrumentation. 
This allows us to provide the user a configuration file and template which can be used to specify the level of instrumentation (e.g., all entry and exit points for instrumentation), or names of specific target functions, and the instrumentation to be applied to them.
Subsequently in ColdPatch we generate our meta-data list, and use it to HotPatch and apply instrumentation at run-time.

\subsubsection{Developer Driven Macros}
% To provide further flexibility, iProbe provides a developer driven mode using user placed macros as required. 
%For example, compiler based instrumentation is able to insert entry and exit of each function(or other programming abstractions), however at times it may be required to inspect a certain line of code or instruction.
Compiler assisted instrumentation may not provide complete flexibility (usually works on abstractions, such as enter/exit of functions), hence for further flexibility, iProbe provides the user with a header file with calls to macros which can be used to add probe points in the binary.
A call to this macro can be placed as required by the developer. 
The symbol name of the macro is then used in the ColdPatch stage to capture these macros as probe points, and convert them to \texttt{NOP}s.
Since the macros are predefined, they can be safely inserted and interpreted by ColdPatcher.
The HotPatching mechanism is very much the same, using the probe list generated by ColdPatch.
